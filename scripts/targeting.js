/**
 * targeting.js
 * PRAAXIS_ALPHA Automation Suite (v2.10, 2025-07-24)
 * Author: Salvo Praxis (Robert Cleaver)
 * Usage: run targeting.js [--advanced] [--min-hack-level N] [--max-hack-level N] [--min-money N] [--write] [--max-targets N] [--help]
 * Output: /data/distributed-targets.txt
 */

/** @param {NS} ns **/
export async function main(ns) {
    // === COLOR + BIOS OUTPUT CONSTANTS ===
    const color = {
        reset: "\u001b[0m",
        white: "\u001b[37m",
        cyan: "\u001b[36m",
        green: "\u001b[32m",
        brightGreen: "\u001b[92m",
        red: "\u001b[31m",
        yellow: "\u001b[33m",
        magenta: "\u001b[35m"
    };
    function BIOS(type, ctx, msg, icon = "") {
        let tcol = color.cyan;
        if (type === "success") tcol = color.brightGreen;
        else if (type === "error" || type === "terminate") tcol = color.red;
        else if (type === "summary") tcol = color.cyan;
        else if (type === "targeting") tcol = color.yellow;
        return (
            `${color.white}[${tcol}${(type || "INFO").toUpperCase()}${color.white}]`
            + `[${color.white}${ctx}${color.white}] ${msg}${icon ? " " + icon : ""}${color.reset}`
        );
    }
    function fit(str, width) {
        if (str.length > width) return str.slice(0, width - 1) + "…";
        return str.padEnd(width, " ");
    }
    function colorScore(score, min, max, width) {
        if (isNaN(score)) return color.white + fit("-", width) + color.reset;
        let ratio = (score - min) / Math.max(max - min, 1);
        let raw = fit(score.toFixed(1), width);
        if (ratio < 0.2) return color.red + raw + color.reset;
        if (ratio < 0.5) return color.yellow + raw + color.reset;
        if (ratio < 0.8) return color.green + raw + color.reset;
        return color.brightGreen + raw + color.reset;
    }

    // Output buffer for BIOS-style output
    let outBuffer = [];
    function print() { outBuffer.forEach(line => ns.tprint(line)); }

    // === ARGUMENTS & FILES ===
    const args = ns.flags([
        ["advanced", false],
        ["min-hack-level", 0],
        ["max-hack-level", 0],
        ["min-money", 0],
        ["write", false],
        ["max-targets", 0],
        ["help", false]
    ]);
    const knownServersFile = "/data/known-servers.txt";
    const outputFile = "/data/target-list.txt";

    if (args.help) {
        outBuffer.push(BIOS("summary", "HELP", `
Usage:
  run targeting.js [--advanced] [--min-hack-level N] [--max-hack-level N] [--min-money N] [--write] [--max-targets N] [--help]

Flags:
  --advanced           Use advanced ranking logic (future expansion)
  --min-hack-level N   Only include servers with required hacking level ≤ N (default: player level)
  --max-hack-level N   Only include servers with required hacking level ≤ N (0 = no limit)
  --min-money N        Minimum server maxMoney for inclusion
  --write              Write ranked targets to ${outputFile}
  --max-targets N      Maximum number of top-ranked targets to write (0 = optimal/all)
  --help               Show this help text

Notes:
- Reads servers from ${knownServersFile} (generated by crawler.js)
- Ranked by (maxMoney * hackChance / hackTime) as default.
- Output is colorized and aligned in BIOS-format for PRAAXIS_ALPHA.
        `.trim()));
        print(); return;
    }

    // === LOAD & PARSE SERVER LIST ===
    // Parse known-servers.txt for all valid server names
    let servers = [];
    try {
        const raw = ns.read(knownServersFile).split("\n");
        for (const line of raw) {
            const [host] = line.split(":");
            if (host && ns.serverExists(host.trim())) servers.push(host.trim());
        }
    } catch (e) {
        outBuffer.push(BIOS("error", "TARGETING", `Could not read ${knownServersFile}: ${e}`));
        print(); return;
    }

    // === FILTER & RANK ===
    const myLevel = ns.getHackingLevel();
    const minLevel = args["min-hack-level"] || 0;
    const maxLevel = args["max-hack-level"] || 0;
    const moneyCutoff = args["min-money"] || 0;
    const advanced = !!args.advanced;

    let candidates = [];
    for (const host of servers) {
        if (host === "home") continue;
        if (!ns.hasRootAccess(host)) continue;
        const level = ns.getServerRequiredHackingLevel(host);
        if (level < minLevel) continue;
        if (maxLevel > 0 && level > maxLevel) continue;
        const money = ns.getServerMaxMoney(host);
        if (money < moneyCutoff) continue;
        const time = ns.getHackTime(host);
        const chance = ns.hackAnalyzeChance(host);
        if (money <= 0 || chance <= 0) continue;

        // Scoring logic (vanilla/advanced - can be expanded)
        let score = (money * chance) / time;
        if (advanced) {
            // Expand with future factors here!
            // Example: score *= (1 + Math.log10(money)); // placeholder
        }

        candidates.push({ host, score, money, chance, time, level });
    }

    candidates.sort((a, b) => b.score - a.score);

    const scores = candidates.map(r => r.score);
    const minScore = Math.min(...scores, 0);
    const maxScore = Math.max(...scores, 1);

    // Optimal thread logic (simple)
    let totalThreads = 0;
    const homeRam = ns.getServerMaxRam("home") - ns.getServerUsedRam("home");
    const homeScriptRam = ns.getScriptRam("/scripts/hgw-highram.js", "home");
    totalThreads += Math.floor(homeRam / homeScriptRam);

    let cumulativeScore = 0, totalScore = candidates.reduce((sum, r) => sum + r.score, 0);
    let optimalTargets = 1;
    for (const [i, rank] of candidates.entries()) {
        cumulativeScore += rank.score;
        if (cumulativeScore / totalScore >= 0.9 || i + 1 >= Math.floor(totalThreads)) {
            optimalTargets = i + 1;
            break;
        }
    }
    optimalTargets = Math.max(1, Math.min(optimalTargets, Math.floor(totalThreads)));

    // Table formatting
    const wHost = 17, wScore = 8, wMoney = 7, wChance = 6, wTime = 8, wLvl = 4;
    outBuffer.push(BIOS("summary", "TARGETING", `Suggested optimal targets: ${optimalTargets}`));
    outBuffer.push(
        color.white +
        "   HOST".padEnd(wHost) +
        "SCORE".padEnd(wScore) +
        "MAX $".padEnd(wMoney) +
        "CHANCE".padEnd(wChance) +
        "T(sec)".padEnd(wTime) +
        "LVL".padEnd(wLvl) +
        color.reset
    );

    const maxTargets = args["max-targets"] || optimalTargets;
    const lines = candidates.slice(0, maxTargets);

    for (const r of lines) {
        const hostRaw = fit(r.host, wHost - 3);
        const hostCol = color.white + " - " + hostRaw + color.reset;
        const scoreCol = colorScore(Number(r.score), minScore, maxScore, wScore);
        let moneyRaw = fit("$" + ns.formatNumber(r.money, "0.00a"), wMoney);
        const moneyCol = color.green + moneyRaw + color.reset;
        let chanceRaw = fit((r.chance * 100).toFixed(0) + "%", wChance);
        const chanceCol = color.yellow + chanceRaw + color.reset;
        let timeRaw = fit(r.time.toFixed(1), wTime);
        const timeCol = color.cyan + timeRaw + color.reset;
        let levelRaw = fit(String(r.level), wLvl);
        const levelCol = color.magenta + levelRaw + color.reset;
        outBuffer.push(
            hostCol + " " + scoreCol + moneyCol + chanceCol + timeCol + levelCol
        );
    }

    if (args.write) {
        ns.write(outputFile, lines.map(r => r.host).join("\n"), "w");
        outBuffer.push(BIOS("success", "TARGETING", `${lines.length} targets written to ${outputFile}.`));
    }

    outBuffer.push(BIOS("terminate", "TARGETING", `Done.`));
    print();
}
